# frozen_string_literal: true

module DataStructures
  # SuffixArray is a data structure that allows for fast substring queries in a
  # string. It is implemented using the suffix array algorithm.
  # It is a space-efficient alternative to a suffix tree.
  # Which in turn is a space-efficient alternative to a trie.
  class SuffixArray
    # @return [String] the string that this suffix array is built on
    attr_reader :string

    # @return [Array] the sorted array of indices
    attr_reader :arr

    def initialize(string)
      @string = string
      @arr = (0...string.length).to_a

      @arr.sort! do |i, j|
        while i < string.length && j < string.length && string[i] == string[j]
          i += 1
          j += 1
        end

        if i == string.length
          -1
        elsif j == string.length
          1
        else
          string[i] <=> string[j]
        end
      end
    end

    # LongestCommonPrefixArray is a data structure that tracks how many characters
    # two sorted adjacent suffixes have in common in the prefix.
    class LongestCommonPrefixArray
      extend Forwardable

      # @return [Array] the array of longest common prefix values
      attr_reader :arr

      # @return [SuffixArray] the suffix array that this array is built on
      attr_reader :sa

      def_delegator :sa, :string

      def initialize(string)
        @sa = SuffixArray.new(string)
        @arr = Array.new(string.length, 0)

        i = 1
        @sa.arr.each_cons(2) do |a, b|
          sum = 0
          while a < string.length && b < string.length && string[a] == string[b]
            sum += 1

            a += 1
            b += 1
          end

          @arr[i] = sum
          i += 1
        end
      end

      def unique_substrings_count
        # This works because the substrings are: 1 entire string, 2 strings of
        # length len - 1, 3 strings of length len - 2, ..., len strings of length 1.
        # which becomes list of len natural numbers, whose sum is n * (n + 1) / 2
        total = string.length * (string.length + 1) / 2

        # Reason why this works is fun:
        # * SuffixArray array holds the longest substring starting from each character.
        # * ALL THE OTHER SUBSTRINGS CAN BE GENERATED BY REMOVING CHARACTERS FROM
        #   THE END OF THESE SUBSTRINGS.
        #   We don't need to chop these substrings in between their middle
        #   because then the starting character would be different and those
        #   substrings would already be included in the array. e.g.
        #   for string "ABC", the SuffixArray would hold: ["ABC", "BC", "C"]
        #   We don't need to cut "ABC"(index 0) from the middle to get the
        #   substring "BC", since that is already handled on the last index.
        #   We also not need to cut "ABC" from the front and the end to get "B",
        #   since that is again handled by just removing a character from "BC"'s
        #   end.
        # * If you get the above, then the rest is easy, the longest common
        #   prefix is the longest common substring between two larger substrings.
        #   Which, as we recall holds all the smaller substrings starting from
        #   a character.
        # * So, if we just we keep removing characters from the end of the
        #   prefix, then we get the other common substrings.
        #
        # Let's take an example to complete this understanding: "ABAB"
        # The Suffix Array is ["AB", "ABAB", "B", "BAB"]
        # The LCP Array is [0, 2, 0, 1]
        # All the substrings, sorted: "A", "A", "AB", "AB", "ABA", "ABAB", "B",
        # "B", "BA", "BAB"
        # The non unique substrings are: "A", "AB" and "B"
        # If we look at the LCP Array, we see that the "AB" and "ABAB" have 2 chars in common
        # So, till "AB" it is common. This is one common substring. If we cut one
        # character from the back and get "A", it is the other common substring.
        # Similarly, "B" and "BAB" have 1 char in common, so we get "B" as the common substring.
        repeated = arr.sum

        total - repeated
      end
    end
  end
end
